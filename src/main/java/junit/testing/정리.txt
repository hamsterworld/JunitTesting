- 2장. 단위 테스트란 무엇인가?

    단위 테스트는 3가지로 정리할수있다.

    1. 작은 코드 조각을 검증한다.
       => 우리가 sut 로 하나하나 작게 검증하듯이 이러한 작은 코드조각들을 검증한다는뜻.
    2. 빠르게 수행한다.
       => 말그대로 외부 프로세스없이 순수 자바코드로만 실행되야 가장빠르다.
    3. 격리된 방식으로 처리되야 한다.

    격리된 방식에대해서 런던파와 고전파의 차이란?

    공유의존성과 비공유의존성이란?

    필자가 말하기를 런던파가 고전파에 비해 선호되지 않는 이유는?

- 3장. 단위 테스트 구조

- 4장. 좋은 단위 테스트의 4대 요소

    1. 회귀방지
        1-1. 테스트중에 실행되는 코드양
        1-2. 코드 복잡도
        1-3. 도메인 유의성

    2. 리팩터링 내성
        거짓양성
        => 결과에 주목하지못하고 내부구현에 집중하면 리팩터링내성은 완전히 0 이다.

    3. 빠른 피드백

    4. 유지보수성

 단위테스트 -> 통합테스트 -> 엔드투엔드테스트

 1. 오른쪽으로 갈수록 회귀방지는 높아지나 빠른피드백효과는 낮아진다.
 2. 리팩토링내성은 둘중 하나이다. 무조건있거나 무조건없거나. 그러므로 항상 최대치를 할수있도록 해야한다.
 3. 회귀방지와 빠른피드백에서 어느게 더 나을지 생각해야한다.

 화이트박스Test vs 블랙박스Test

 화이트박스는 내부구현까지 확인한다고 보면 편하다.
 블랙박스는 출력만을 확인한다.
 우리는 리팩토링내성을 포기할수없다 그러므로, 항상 화이트박스테스트가 기본이되고 우선시되야한다.

- 5장. 목과 테스트 취약성

    목이 취약한 테스트 = 리팩터링 내성이 부족한 테스트

    - 테스트 대역
        1. 목 => 외부로 나가는 상호작용 , SUT 가 상태를 변경하기위해 의존성 호출
        2. 스텁 => 내부로 들어오는 상호작용, SUT 가 입력데이터를 얻기위해 의존성을 호출

    - 식별할수있는 동작과 구현세부사항
        식별할수있는 동작 = 공개된 API (public,protected)
        구현 세부 사항 = 공개되지않은 API (package-private,private)

        구현세부사항을 외부에 노출하면안된다 => 우리는 캡슐화를 해야한다.
        서로가 내부구현사항을 절대 알고있으면안된다.
        공개된 API 만을 통해 원하는 목표를 완성할것.

        즉, 코드가 많아지고 복잡해져도 장기적으로 유지보수를 위해서라면 캡슐화는 필수적이다.
        물론, 캡슐화는 내부 상태또한 공개된 API 에의해서만 조작되야하며, 내부구현이 유출되서 내부상태가 멋대로 변화하면안된다.
        가장좋은건 내부상태가, 불변인게 제일 좋다.

    - 육각형 아키텍처 정의
        - 전형적인 애플리케이션은 애플리케이션계층과 서비스계층이라는 두계층으로 구성된다.
        1. 애플리케이션계층은 외부 환경과 통신을 조정
        2. 서비스계층은 비즈니스로직을 담당하고 이는 App 에서 가장 중요한 부분이다.
           가장 중요한 부분이므로 모든 책임에서 벗어나야한다. 그래서, 외부와 통신하거나 데이터베이스 CRUD 와 같은부분은 애플리케이션 계층에 귀속되야한다.
           반대로 애플리케이션계층에서는 어떠한 비즈니스로직이 있어서도 안된다.

        - 도메인계층은 애플리케이션계층과 완전히 독립적으로 구성되어야한다.
           도메인 계층은 외부환경과 완전히 격리되어야한다는 것이다.
           또한 도메인계층에 외부통신이 직접 연결되면 안된다.

        ex-1) repository 를 보면 이부분만 외부와 통신하여 데이터를 가져오고 domain 로직과는 완전히 분리되어있다.
        도메인 로직은 이제 side-effect 를 가지는 것들이 없다. 여기서 쓰이는 domain 들은 사실상 함수형코어마냥
        계산만 하고 입출력을 하기때문에 굉장히 테스트하기 편한 코드이다.

- 6장. 단위 테스트 스타일

    단위 테스트 스타일 3가지
        1. 출력 기반

            f(x) = x + 1
            f(1) = ?
            assertions(2);
            이런 스타일이 출력기반

        2. 상태 기반
            class 필드가 name 일때
            People("hamster");

            People.name == "hamster" 냐?
            이런 내부상태를 확인하는것이 상태기반이다.

        3. 통신 기반


    - 출력기반 테스트가 제일좋고 그다음이 상태기반테스트이다. 통신기반 테스트는 고려대상이 아니다. 애초에 알필요도없음.

    함수형 아키텍쳐란?
        출력기반 테스트를 함수형이라고도 한다.

    package ch6 에서

        oneStep
        1. 통합테스트에 가깝다.
        2. 리팩토링내성과 회귀방지는 좋다.
        3. 단위테스트가 아니다.

        twoStep
        1. service 단계에서 Repo 를 interface 로 받아서 Mock 처리 해준다는 느낌이다.
        interface 가 하나만의 구체클래스를 가지고있다면 그것은 Mock 처리를 위한것이지 그이상 그이하도 아니다.
        2. 어쨋든 이런 외부의존성을 Mock 처리 하는것은 모범적인 Mock 사용 방법이다.

        threeStep
        1. 함수형 아키텍처로 최대한 설계
        2. 우리가 흔히 사용하는 MVC 에서 Service 이다.
        Repo 와 같은 사이드이펙트를 최대한 분리해낸것
        Domain 로직을 타고 최종 결과를 Repo,I/O,mail System..등으로 write 한다.
        물론, 중간에 Domain 도 내부 상태를 변경한다던지등등 사이드이펙트를 발생시킬수있지만
        함수형 아키텍처의 목표는 완전한 분리가 아닌 최대한의 분리이다.

        advanced threeStep
        1. 함수형 아키텍처로 항상 설계할수는없다.
        2. 만약에 24시간동안 너무 많은 방문자가 발생해서 .txt 에 방문자기록이 남겨질려면
        일정 접근레벨이 있어야 된다고 가정해보자.
        그럴때 .txt 용량을 조사해서 한다고했을때
        일단은, Read 해서 읽은다음에 쓰기전에 계산해야한다.
        근데 이 로직이 manager 안에있다. 그러므로 사용자의 레벨을 조사알지말지
        이안에서 정해지게되는데 그러면 2가지방법이있다.

            1. manager 안에 side-effect 를 발생시키는 Repo,I/O가 들어가게된다.
            그리고 용량을 계산한후 너무많은 방문자가 발생했다면 side-effect 로직인 write 로 방문자 레벨을 조사한다.
            이방법은 성능에는 좋지만, 어느정도의 side-effect 분리를 포기한다.

            2. 분리를 포기하지않고, 성능이 하락하는 대신
            먼저 그냥 방문자 레벨이 필요할지 안할지모르지만 application Layer 쪽에서 먼저 조사해온다.
            manager 에서 필요하면 사용하고 필요없으면 사용하지않는다.

            결론, 함수형아키텍처는 항상 성능과분리 둘다 만족시킬수는없다.
